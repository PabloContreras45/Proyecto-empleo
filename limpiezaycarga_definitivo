from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
from bs4 import BeautifulSoup
import pandas as pd
from time import sleep
import requests
import sqlite3
import re
from sklearn.cluster import KMeans
import plotly.io as pio
import plotly.express as px
import plotly.graph_objects as go
import nbformat
# Lee el archivo CSV
df = pd.read_csv('portales_empleo.csv')

# Muestra las primeras filas del DataFrame
print(df.head())

df = df.drop(columns=['Unnamed: 0'])
# Eliminar filas duplicadas en su totalidad
df = df.drop_duplicates()
df.info()

df.head(5)

# Función para limpiar el salario:
def limpieza_salario(rango_salarios):
    rango_salarios = rango_salarios.replace('EUR','').replace(',','')
    rango = rango_salarios.split(' - ')

    salario_min = int(rango[0])
    salario_max = int(rango[1])

    #Devolvemos la media
    return (salario_max+salario_min)//2

df['Sueldo medio'] = df['Sueldo'].apply(limpieza_salario)
df = df.drop(columns='Sueldo')


# Elimina el texto entre paréntesis en la columna 'título'
df['Título'] = df['Título'].str.replace(r'\(.*?\)', '', regex=True)

# Elimina los signos '|' y '/'
df['Título'] = df['Título'].str.replace(r'[|/]', '', regex=True)

# Elimina espacios en blanco adicionales
df['Título'] = df['Título'].str.strip()

# Elimina el texto entre corchetes en la columna 'título'
df['Título'] = df['Título'].str.replace(r'\[.*?\]', '', regex=True)

# Elimina los signos '|', '/' y '-'
df['Título'] = df['Título'].str.replace(r'[|/-]', '', regex=True)

# Elimina espacios en blanco adicionales
df['Título'] = df['Título'].str.strip()

# Muestra las primeras filas del DataFrame
df.head(5)
# Función para actualizar títulos
def actualizar_titulo(titulo):
    # Reemplazar 'jr' por 'Junior' y 'sr' por 'Senior'
    titulo = titulo.replace(' jr ', ' Junior ').replace(' sr ', ' Senior ')
    titulo = titulo.replace('jr ', 'Junior ').replace('sr ', 'Senior ')
    titulo = titulo.replace(' jr', ' Junior').replace(' sr', ' Senior')
    return titulo

# Aplicar la función de actualización a la columna 'Título'
df['Título'] = df['Título'].apply(actualizar_titulo)
def get_expertise(title):
    if 'Senior' in title or 'senior' in title or 'master' in title or 'manager' in title:
        return 'Senior'
    elif 'Junior' in title or 'junior' in title:
        return 'Junior'
    elif 'intern' in title or 'becario' in title:
        return 'Intern'
    elif 'Lead' in title or 'lead' in title:
        return 'Lead' 
    else:
        return 'Regular'

# Crear la nueva columna "Expertise" aplicando la función sobre la columna "Título"
df['Expertise'] = df['Título'].apply(get_expertise)
import re
# Listas de palabras clave (nombres de empresas y sectores)
empresas = ['santander', 'amazon', 'microsoft', 'vie', 'bcg', 'mckinsey']  # Añadir más nombres de empresas
sectores = ['marketing', 'medtech', 'fintech', 'ecommerce', 'finance', 'game','genai','digital', 'tax', 'governance', 'energy' ]  # Añadir más sectores

# Convertir las listas a un conjunto de expresiones regulares para facilitar la búsqueda
regex_empresas = re.compile(r'\b(' + '|'.join(empresas) + r')\b', re.IGNORECASE)
regex_sectores = re.compile(r'\b(' + '|'.join(sectores) + r')\b', re.IGNORECASE)

# Función para extraer empresa
def extraer_empresa(titulo):
    match = regex_empresas.search(titulo)
    return match.group(0) if match else None

# Función para extraer sector
def extraer_sector(titulo):
    match = regex_sectores.search(titulo)
    return match.group(0) if match else None

# Función para limpiar el título
def limpiar_titulo(titulo):
    # Eliminar nombres de empresas y sectores del título
    titulo = regex_empresas.sub('', titulo)
    titulo = regex_sectores.sub('', titulo)
    # Eliminar espacios extra
    return ' '.join(titulo.split())

# Aplicar las funciones a las columnas del DataFrame
df['Empresa'] = df['Título'].apply(extraer_empresa)
df['Sector'] = df['Título'].apply(extraer_sector)
df['Título'] = df['Título'].apply(limpiar_titulo)
df.head(12)
# Detecta la palabra clave "Inglés" y asigna a la nueva columna 'Otro Idioma'
df['Otro Idioma'] = df['Título'].apply(lambda x: 'inglés' if 'inglés' in x else None)

# Detecta la palabra clave "Inglés" y asigna a la nueva columna 'Otro Idioma'
df['Otro Idioma'] = df['Título'].apply(lambda x: 'English' if 'English' in x else None)

# Detecta las palabras clave "Híbrido", "Remoto" o "Presencial" y asigna a la nueva columna 'Modalidad'
df['Modalidad'] = df['Título'].apply(lambda x: 'Híbrido' if 'Híbrido' in x else ('Remoto' if 'Remoto' in x else ('Presencial' if 'Presencial' in x else None)))

df['Otro Idioma'] = df['Título'].apply(lambda x: 'english' if 'english' in x else None)
df['Otro Idioma'] = df['Título'].apply(lambda x: 'french' if 'french' in x else None)
df['Otro Idioma'] = df['Título'].apply(lambda x: 'francés' if 'francés' in x else None)
# Función para detectar los idiomas
def detectar_idiomas(titulo):
    if 'inglés' in titulo.lower() or 'english' in titulo.lower():
        return 'Inglés'
    elif 'francés' in titulo.lower() or 'french' in titulo.lower():
        return 'Francés'
    # Puedes añadir más idiomas aquí
    return None

# Aplicar la función para detectar idiomas
df['Otro Idioma'] = df['Título'].apply(detectar_idiomas)
titulos_agrupados = df['Otro Idioma'].value_counts()
print(titulos_agrupados)
# Diccionario de ubicaciones y sus modificaciones
ubicaciones_dict = {
    'Boadilla del Monte': 'Madrid',
    'Alcobendas': 'Madrid',
    'Leganés': 'Madrid',
    'Getafe': 'Madrid',
    'Barcelona, Centro': 'Cataluña',
    'Esplugues de Llobregat': 'Cataluña',
    'Barcelona': 'Cataluña',
    'Pozuelo de Alarcón': 'Madrid',
    'Tres Cantos': 'Madrid',
    'Villaviciosa de Odón': 'Madrid',
    'Sant Just Desvern': 'Cataluña'
}

# Función para reemplazar la ubicación según el diccionario
df['Ubicación'] = df['Ubicación'].replace(ubicaciones_dict)
titulos_agrupados = df['Ubicación'].value_counts()
print(titulos_agrupados)
titulos_agrupados = df['Empresa'].value_counts()
print(titulos_agrupados)
# Remover caracteres innecesarios y estandarizar
df['Título'] = df['Título'].str.replace(r'[^\w\s]', '', regex=True).str.strip().str.lower()
# Crear columna de 'Puesto' principal basado en palabras clave
def clasificar_rol(titulo):
    if 'data scientist' in titulo:
        return 'Data Scientist'
    elif 'data applied scientist ii at barcelona spain' in titulo:
        return 'Data Scientist'
    elif 'data engineer' in titulo:
        return 'Data Engineer'
    elif 'analyst' in titulo:
        return 'Data Analyst'
    elif 'machine learning' in titulo:
        return 'Machine Learning Engineer'
    elif 'business intelligence' in titulo:
        return 'Business Intelligence'
    elif 'consultant' in titulo:
        return 'Consultant'
    elif 'specialist' in titulo:
        return 'Data Specialist'
    else:
        return 'Other'

df['Puesto'] = df['Título'].apply(clasificar_rol)
# Reordenar columnas en el orden especificado
columnas_ordenadas = [
    'Título', 'Puesto', 'Sueldo medio','Expertise', 'Empresa', 'Modalidad', 'Sector', 
    'Ubicación', 'Descripción', 'Servicios', 'Otro Idioma'
]
df = df[columnas_ordenadas]
# Función para clasificar el puesto basado en palabras clave extendidas
def clasificar_rol(titulo):
    titulo = titulo.lower()
    if 'data scientist' in titulo:
        return 'Data Scientist'
    elif 'data applied scientist ii at barcelona spain' in titulo:
        return 'Data Scientist'
    elif 'data engineer' in titulo:
        return 'Data Engineer'
    elif 'data manager' in titulo or 'manager data' in titulo:
        return 'Data Manager'
    elif 'head of data' in titulo:
        return 'Data Manager'
    elif 'data expert' in titulo:
        return 'Data Expert'
    elif 'big data architect' in titulo:
        return 'Big Data Architect'
    elif 'manager data cloud' in titulo:
        return 'Data Manager Cloud'
    elif 'data analytics' in titulo:
        return 'Data Analytics'
    elif 'ai innovation architect' in titulo:
        return 'AI Innovation Architect'
    elif 'data management engineer' in titulo:
        return 'Data Manager'
    elif 'business intelligence' in titulo:
        return 'Business Intelligence'
    elif 'analyst' in titulo:
        return 'Data Analyst'
    elif 'consultant' in titulo:
        return 'Consultant'
    elif 'machine learning' in titulo:
        return 'Machine Learning Engineer'
    elif 'specialist' in titulo:
        return 'Data Specialist'
    elif 'data developer' in titulo:
        return 'Data Developer'
    elif 'project manager' in titulo:
        return 'Project Manager'
    else:
        return 'Other'

# Aplicar la función a la columna "Título" para crear o actualizar la columna "Puesto"
df['Puesto'] = df['Título'].apply(clasificar_rol)

# Función para limpiar nombres de ciudades y códigos de puesto directamente en "Título"
def limpiar_titulo(titulo):
    # Eliminación de nombres de ciudades comunes en títulos
    ciudades = ["barcelone", "alicante", "catalonia", "madrid", "bilbao"]  # Añadir otras ciudades según sea necesario
    for ciudad in ciudades:
        titulo = re.sub(rf"\b{ciudad}\b", "", titulo, flags=re.IGNORECASE)
    
    # Eliminación de códigos de puesto que suelen ser letras y números juntos
    titulo = re.sub(r"\b[a-zA-Z]{2,3}\d{3}\b", "", titulo)
    
    # Eliminación de espacios extras generados por las sustituciones
    titulo = re.sub(r"\s+", " ", titulo).strip()
    return titulo

# Aplicar la función de limpieza a la columna "Título" para modificarla directamente
df['Título'] = df['Título'].apply(limpiar_titulo)

# Función para extraer herramientas tecnológicas
def extraer_herramientas(titulo):
    herramientas = ["Salesforce", "CRM", "Power BI", "Qlik", "Python", "Tableau", "SAS", "SAP", "BigQuery", "Datastage", "Analytics", "Pentaho", "Spark"]  # Añadir otras herramientas según sea necesario
    herramientas_encontradas = [herramienta for herramienta in herramientas if herramienta.lower() in titulo.lower()]
    return ", ".join(herramientas_encontradas) if herramientas_encontradas else None

# Crear la columna "Herramientas" con las herramientas tecnológicas encontradas en el título
df['EntornoTEC'] = df['Título'].apply(extraer_herramientas)
def convertir_abreviaciones(titulo):
    titulo = titulo.lower()  # Convertir a minúsculas para comparación
    if 'sr' in titulo:
        titulo = titulo.replace('sr', 'senior')
    if 'jr' in titulo:
        titulo = titulo.replace('jr', 'junior')
    return titulo

# Aplicar la función para convertir los títulos
df['Título'] = df['Título'].apply(convertir_abreviaciones)
def get_expertise(title):
    if 'Senior' in title or 'senior' in title or 'master' in title or 'manager' in title:
        return 'Senior'
    elif 'Junior' in title or 'junior' in title or 'associate' in title:
        return 'Junior'
    elif 'intern' in title or 'becario' in title or 'becarioa' in title:
        return 'Intern'
    elif 'Lead' in title or 'lead' in title or 'head' in title:
        return 'Lead' 
    else:
        return 'Regular'

# Crear la nueva columna "Expertise" aplicando la función sobre la columna "Título"
df['Expertise'] = df['Título'].apply(get_expertise)
titulos_agrupados = df['Puesto'].value_counts()
# Filtrar filas que contengan el texto deseado en la columna "Título"
filtro = df[df['Puesto'].str.contains("Other", case=False, na=False)]

# Función para agregar espacios entre palabras correctamente
def add_spaces(text):
    # Añade un espacio entre palabras que estén pegadas (ej: "SnacksWeekly" -> "Snacks Weekly")
    corrected_text = re.sub(r'(?<=[a-zA-Z])(?=[A-Z])', ' ', text)
    return corrected_text

# Aplicar la función a la columna "Servicios"
df['Servicios'] = df['Servicios'].apply(add_spaces)
# Lista de palabras comunes a eliminar
common_words = r'\b(de|a|in|or|and|the|of|en|con|para|por|y|del|la|los|las|un|una)\b'

# Definición de las palabras clave para cada categoría
benefits_keywords = r'\b(Tarjeta de restaurante|Teletrabajo opcional|Flexible hours|Modern office environment|Continuous learning programs|Mentoring programs|Collaborative culture|Oportunidades de crecimiento profesional|Paquete competitivo de compensación y beneficios|Retirement program|Well-being programs|Diversity initiatives|Work-life balance|Remote work)\b'
skills_keywords = r'\b(Neural networks|Bayesian modeling|Data storytelling|Análisis de datos|Métodos estadísticos|Business Intelligence|Data Science|Machine Learning|Deep Learning|Data Visualization|Problem Solving|Data Analysis|Reporting|Data governance|Statistical Analysis|Predictive Modeling)\b'
tools_keywords = r'\b(Python|R|Pyspark|Power BI|Tableau|Databricks|GCP|SAS|SQL|Excel|VBA|Google Analytics|Adobe Analytics|Domo|Snowflake|TensorFlow|Keras|Scikit-learn|Power Platforms|Jupyter Notebooks|Azure|AWS|Docker|GitHub|Streamlit|Pytorch|BigQuery|SQL)\b'
education_keywords = r'\b(Degree in Computing or Statistics|Bachelor\'s Degree|Master\'s Degree|PhD|Licenciatura|Grado|Engineering Degree|Data Science Degree|Statistics Degree|Computer Science Degree|Mathematics Degree)\b'

# Función para limpiar texto de palabras comunes
def remove_common_words(text):
    return re.sub(common_words, '', text, flags=re.IGNORECASE)

# Función para clasificar las palabras en las categorías
def classify_services(services):
    # Limpiar palabras comunes
    services_cleaned = remove_common_words(services)
    
    # Clasificar términos en categorías
    benefits = re.findall(benefits_keywords, services_cleaned, flags=re.IGNORECASE)
    skills = re.findall(skills_keywords, services_cleaned, flags=re.IGNORECASE)
    tools = re.findall(tools_keywords, services_cleaned, flags=re.IGNORECASE)
    education = re.findall(education_keywords, services_cleaned, flags=re.IGNORECASE)
    
    # Devolver resultados en columnas separadas
    return pd.Series({
        'Beneficios': ', '.join(benefits) if benefits else None,
        'Habilidades': ', '.join(skills) if skills else None,
        'Herramientas': ', '.join(tools) if tools else None,
        'Educación': ', '.join(education) if education else None,
    })

# Aplicar la función a cada fila
df_new = df['Servicios'].apply(classify_services)

# Concadenamos el df original y el ampliado
df_final = pd.concat([df,df_new],axis=0,ignore_index=True)

df_final = df_final.dropna(subset=['Título'])

df_final['Sueldo_medio'] = df_final['Sueldo medio']
df_final.drop(columns='Sueldo medio')


# Combinar los resultados en un nuevo DataFrame
df_final = pd.concat([df, df_new], axis=1)

df_final.to_csv("Datos_definitivos.csv", index = False)
# Cargar los datos desde un archivo CSV
data = pd.read_csv('Datos_definitivos.csv')

# Verificar las primeras filas de los datos
print(data.head())

# Preparar los datos para el clustering (selecciona las características relevantes)
X = data[['Puesto', 'Expertise', 'Sector']]

# Convertir variables categóricas a numéricas
X['Puesto'] = X['Puesto'].astype('category').cat.codes
X['Expertise'] = X['Expertise'].astype('category').cat.codes
X['Sector'] = X['Sector'].astype('category').cat.codes

# Aplicar K-means para segmentar los datos
kmeans = KMeans(n_clusters=3, random_state=0)
data['Segmento'] = kmeans.fit_predict(X)

# Visualizar la cantidad de ofertas por segmento
segment_counts = data['Segmento'].value_counts().reset_index()
segment_counts.columns = ['Segmento', 'Cantidad']

# Gráfico de barras mostrando la cantidad de ofertas por segmento
fig_barras = go.Figure(data=[
    go.Bar(x=segment_counts['Segmento'], y=segment_counts['Cantidad'], 
           marker=dict(color='royalblue'))
])

# Configurar el layout del gráfico de barras
fig_barras.update_layout(
    title='Cantidad de Ofertas por Segmento',
    xaxis_title='Segmento',
    yaxis_title='Cantidad de Ofertas'
)

# Guardar el gráfico como archivo HTML y abrirlo en el navegador
pio.write_html(fig_barras, 'grafico_barras.html')
import webbrowser
webbrowser.open('grafico_barras.html')

# Gráfico de dispersión mostrando los diferentes segmentos
fig_dispersion = go.Figure()

# Agregar trazas para cada segmento
for segmento in data['Segmento'].unique():
    seg_data = data[data['Segmento'] == segmento]
    fig_dispersion.add_trace(go.Scatter(
        x=seg_data['Puesto'], 
        y=seg_data['Expertise'], 
        mode='markers',
        name=f'Segmento {segmento}',
        text=seg_data['Descripción'],  # Mostrar descripción al pasar el ratón
        marker=dict(size=10)
    ))

# Configurar el layout del gráfico de dispersión
fig_dispersion.update_layout(
    title='Resultados del Análisis de Segmentación',
    xaxis_title='Puesto',
    yaxis_title='Expertise',
    legend_title='Segmentos',
    hovermode='closest'
)

# Guardar el gráfico de dispersión como archivo HTML y abrirlo en el navegador
pio.write_html(fig_dispersion, 'grafico_dispersion.html')
webbrowser.open('grafico_dispersion.html')
# Asegurarte de que el DataFrame tiene los nombres de columnas correctos
df_final.columns = [
    "Título", "Puesto", 'Sueldo_medio',"Expertise", "Empresa", "Modalidad", "Sector", 
    "Ubicación", "Descripción", "Servicios", "Otro_Idioma", "EntornoTEC", 
    "Beneficios", "Habilidades", "Herramientas", "Educación"
]
